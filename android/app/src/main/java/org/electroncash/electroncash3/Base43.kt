package org.electroncash.electroncash3

import kotlin.text.Charsets.US_ASCII

/**
 * Base43 conversion, to use with transaction QRs generated by Electron Cash.
 * Adjusted from the Java implementation by Andreas Schildbach at
 * https://www.javatips.net/api/peercoin-android-wallet-master/wallet/src/com/matthewmitchell/peercoin_android_wallet/util/Base43.java
 */
object Base43 {

    val alphabet: CharArray = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ$*+-./:".toCharArray()
    val indexes: IntArray = IntArray(128)
    fun ByteArray.toHexString() = joinToString("") { "%02x".format(it) }

    init {
        for (i in indexes.indices) {
            indexes[i] = -1
        }
        for (i in alphabet.indices) {
            indexes[alphabet[i].toInt()] = i
        }
    }

    fun encode(input: ByteArray): String {
        var input = input
        if (input.isEmpty()) return ""
        input = copyOfRange(input, 0, input.size)

        // Count leading zeroes.
        var zeroCount = 0
        while (zeroCount < input.size && input[zeroCount].toInt() == 0) ++zeroCount

        // The actual encoding.
        val temp = ByteArray(input.size * 2)
        var j = temp.size
        var startAt = zeroCount
        while (startAt < input.size) {
            val mod: Byte = divmod43(input, startAt)
            if (input[startAt].toInt() == 0) ++startAt
            temp[--j] = alphabet[mod.toInt()].toByte()
        }

        // Strip extra '1' if there are some after decoding.
        while (j < temp.size && temp[j].toChar() == alphabet[0]) ++j

        // Add as many leading '1' as there were leading zeros.
        while (--zeroCount >= 0) temp[--j] = alphabet[0].toByte()
        val output: ByteArray = copyOfRange(temp, j, temp.size)
        return String(output, US_ASCII)
    }

    @Throws(IllegalArgumentException::class)
    fun decode(input: String): String {
        if (input.isEmpty()) return ""
        val input43 = ByteArray(input.length)
        // Transform the String to a base43 byte sequence
        for (i in input.indices) {
            val c = input[i]
            var digit43 = -1
            if (c.toInt() in 0..127) digit43 = indexes[c.toInt()]
            require(digit43 >= 0) { "Illegal character $c at $i" }
            input43[i] = digit43.toByte()
        }

        // Count leading zeroes
        var zeroCount = 0
        while (zeroCount < input43.size && input43[zeroCount].toInt() == 0) ++zeroCount

        // The encoding
        val temp = ByteArray(input.length)
        var j = temp.size
        var startAt = zeroCount
        while (startAt < input43.size) {
            val mod: Byte = divmod256(input43, startAt)
            if (input43[startAt].toInt() == 0) ++startAt
            temp[--j] = mod
        }

        // Do no add extra leading zeroes, move j to first non null byte.
        while (j < temp.size && temp[j].toInt() == 0) ++j

        return copyOfRange(temp, j - zeroCount, temp.size).toHexString()
    }

    private fun divmod43(number: ByteArray, startAt: Int): Byte {
        var remainder = 0
        for (i in startAt until number.size) {
            val digit256 = number[i].toInt() and 0xFF
            val temp = remainder * 256 + digit256
            number[i] = (temp / 43).toByte()
            remainder = temp % 43
        }
        return remainder.toByte()
    }

    private fun divmod256(number43: ByteArray, startAt: Int): Byte {
        var remainder = 0
        for (i in startAt until number43.size) {
            val digit58 = number43[i].toInt() and 0xFF
            val temp = remainder * 43 + digit58
            number43[i] = (temp / 256).toByte()
            remainder = temp % 256
        }
        return remainder.toByte()
    }

    private fun copyOfRange(source: ByteArray, from: Int, to: Int): ByteArray {
        val range = ByteArray(to - from)
        System.arraycopy(source, from, range, 0, range.size)
        return range
    }
}